package main

import (
	"bytes"
	"crypto/tls"
	"flag"
	"fmt"
	"github.com/gomarkdown/markdown"
	"github.com/gomarkdown/markdown/html"
	"github.com/gomarkdown/markdown/parser"
	"golang.org/x/crypto/acme/autocert"
	"html/template"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

type programArguments struct {
	showHelp bool

	// startup settings
	port         int
	autocert     string
	hideListing  bool
	templatePath string

	// request handling settings
	requireExt  bool
	dir         string
	media       string
	mediaPrefix string
}

func parseProgramArguments(args []string) (programArguments, error) {
	progArgs := programArguments{}

	set := flag.NewFlagSet("mdserve", flag.ContinueOnError)

	set.BoolVar(&progArgs.showHelp, "help", false, "show help")
	set.BoolVar(&progArgs.showHelp, "h", false, "show help (shorthand)")

	set.IntVar(&progArgs.port, "port", 8080, "port to receive HTTP requests")
	set.IntVar(&progArgs.port, "p", 8080, "port to receive HTTP requests (shorthand)")
	set.StringVar(&progArgs.autocert, "autocert", "", "domain name for autogenerated SSL cert; ignored when empty; requireds port :443")
	set.BoolVar(&progArgs.hideListing, "hideListing", false, "do not list files when directories are requested")
	set.StringVar(&progArgs.templatePath, "template", "", "path to template file; or empty to use default")

	set.BoolVar(&progArgs.requireExt, "ext", false, "require .md extension when routing requests")
	set.StringVar(&progArgs.dir, "dir", ".", "path to directory of markdown files")
	set.StringVar(&progArgs.media, "media", "", "local path to media files; or empty to disable")
	set.StringVar(&progArgs.mediaPrefix, "mediaPrefix", "/static", "url prefix to serve media files; or empty to disable")

	err := set.Parse(args)

	if progArgs.showHelp {
		set.Usage()
		err = flag.ErrHelp // set err since we showed program usage.
	}
	return progArgs, err

}

type statusCodeCapturer struct {
	statusCode     int
	originalWriter http.ResponseWriter
}

func newStatusCodeCapturer(w http.ResponseWriter) *statusCodeCapturer {
	return &statusCodeCapturer{
		statusCode:     0,
		originalWriter: w,
	}
}

func (capturer *statusCodeCapturer) Header() http.Header {
	return capturer.originalWriter.Header()
}

func (capturer *statusCodeCapturer) Write(b []byte) (int, error) {
	if capturer.statusCode == 0 {
		capturer.statusCode = 200
	}

	return capturer.originalWriter.Write(b)
}

func (capturer *statusCodeCapturer) WriteHeader(i int) {
	capturer.statusCode = i
	capturer.originalWriter.WriteHeader(i)
}

var defaultTemplateContent = `
<html>
	<head>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mini.css/3.0.1/mini-default.min.css">
		<title>{{ if .Node.IsDir }}&#x1F4C2;{{else}}&#x1F4C4;{{ end }} {{.Node.Name | title | underscoresToSpaces }}</title>
		<style>
		html, body {
			background-color: #F0F0F0;
		}

		nav {
			padding: 3em;
			background-color: #ffffff;
		}

		nav .header {
			width: 100%;
			border-bottom: 1px solid RGB(227, 227, 227);
		}

		article {
			padding: 3em;
			background-color: var(--nav-back-color);
			border: .0625rem solid var(--nav-border-color);
			border-radius: var(--universal-border-radius);
			margin: var(--universal-margin);
		}
		</style>
	</head>
	<body>
		<main class="responsive-margin responsive-padding container">
			  <div class="row">
				<div class="col-md-2"></div>
				<div class="col-md-8 col-sm-12">
					<nav id="index">
						<div class="header">Index of {{ .Node.RelativeURL }}</div>
						<a href="../" class="sublink-1">&#10548; Up to parent directory</a>
						{{ range .Children }}
							{{ if .IsDir }}
								<a href="{{ .RelativeURL.String }}" class="sublink-1">&#x1F4C2; {{ .Name }}</a>
							{{ end }}
						{{ end }}
						{{ range .Children }}
							{{ if not .IsDir }}
								<a href="{{ .RelativeURL.String }}" class="sublink-1">&#x1F4C4; {{ .Name }}</a>
							{{ end }}
						{{ end }}
					</nav>
					{{ if not .Node.IsDir }}
					<article>
						{{ .Content }}
					</article>
					{{ end }}
				</div>
				<div class="col-md-2"></div>
			  </div>
			{{ if .Error }}
				{{ .Status }} : {{ .Error }}
			{{ else }}

			{{ end }}
		</main>
		<!--<footer class="responsive-margin responsive-padding">
			<p>last modified: {{ .Node.ModTime }}</p>
		</footer>-->
	</body>
</html>
`

type templateDataBuilder struct {
	data templateData
}

func newTemplateDataBuilder() *templateDataBuilder {
	return &templateDataBuilder{templateData{}}
}

func (builder *templateDataBuilder) WithContent(content string) *templateDataBuilder {
	builder.data.Content = template.HTML(content)
	return builder
}

func (builder *templateDataBuilder) WithNode(node Node, parent Node, children []Node) *templateDataBuilder {
	builder.data.Node = node
	builder.data.Parent = parent
	builder.data.Children = children

	return builder
}

func (builder *templateDataBuilder) WithError(err error, status int) *templateDataBuilder {
	builder.data.Error = err
	builder.data.HTTPStatus = status

	return builder
}

func (builder templateDataBuilder) Build() templateData {
	return builder.data
}

type templateData struct {
	Error      error
	HTTPStatus int

	Node Node
	Parent Node
	Children []Node

	Content template.HTML
}

type Node interface {
	IsDir() bool
	ModTime() time.Time
	Name() string
	RelativeURL() *url.URL
}

type node struct {
	isDir    bool
	modTime  time.Time
	name     string
	relUrl   *url.URL
}

func (n node) IsDir() bool           { return n.isDir }
func (n node) ModTime() time.Time    { return n.modTime }
func (n node) Name() string          { return n.name }
func (n node) RelativeURL() *url.URL { return n.relUrl }

func makeNode(isDir bool, modTime time.Time, name string, rawRelURL string) (node, error) {
	relUrl, err := url.Parse(rawRelURL)
	if err != nil {
		return node{}, err
	}
	return node{
		isDir:    isDir,
		modTime:  modTime,
		name:     name,
		relUrl:   relUrl,
	}, nil
}

func readNodes(dirMask string, path string) (Node, []Node, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, nil, err
	}
	info, err := f.Stat()
	if err != nil {
		return nil, nil, err
	}

	relURL := path[len(dirMask):]
	if relURL == "" {
		relURL = "/"
	}

	root, err := makeNode(info.IsDir(), info.ModTime(), info.Name(), relURL)
	if err != nil {
		return nil, nil, err
	}

	if !info.IsDir() {
		return root, nil, nil
	}

	contents, err := f.Readdir(0)
	if err != nil {
		return nil, nil, err
	}

	children := make([]Node, 0)

	for _, c := range contents {
		subPath := filepath.Join(path, c.Name())

		subFile, err := os.Stat(subPath)
		if err != nil {
			return nil, nil, err
		}

		node, err := makeNode(subFile.IsDir(), subFile.ModTime(), subFile.Name(), subPath[len(dirMask):])
		if err != nil {
			return nil, nil, err
		}

		if subFile.IsDir() || filepath.Ext(subPath) == ".md"{
			children = append(children, node)
		}
	}

	if len(children) > 0 {
		sort.Slice(children, func(i, j int) bool {
			return children[i].Name() < children[j].Name()
		})
	}

	return root, children, nil
}

var templateFunctions = template.FuncMap{
	"title": strings.Title,
	"underscoresToSpaces": func(s string) string {
		return strings.Replace(s, "_", " ", -1)
	},
	"hyphensToSpaces": func(s string) string {
		return strings.Replace(s, "-", " ", -1)
	},
	"removeExtension": func(s string) string {
		ext := filepath.Ext(s)
		return s[0 : len(s)-len(ext)]
	},
	"base": filepath.Base,
	"dir": filepath.Dir,
}

type markdownHandler struct {
	requireExt  bool
	hideListing bool
	dir         string
	media       string
	mediaPrefix string
	template    *template.Template
}

func (handler markdownHandler) handle(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	wrapper := newStatusCodeCapturer(w)
	defer func() {
		dur := time.Since(start)
		status := wrapper.statusCode

		log.Printf("method=%s host=%s path=%s status=%d dur=%s\n", r.Method, r.Host, r.URL.Path, status, dur)
	}()

	if r.Method != http.MethodGet {
		wrapper.WriteHeader(405)
		return
	}

	extension := filepath.Ext(filepath.Clean(r.URL.Path))
	isMediaFile := extension != "" && extension != ".md"
	if isMediaFile {
		handler.handleMedia(wrapper, r)
		return
	}

	handler.handleMarkdown(wrapper, r)
}

// handleMarkdown attempts to render HTML for the requested markdown file or directory.
func (handler markdownHandler) handleMarkdown(w http.ResponseWriter, r *http.Request) {
	cleanPath := filepath.Clean(r.URL.Path)
	extension := filepath.Ext(cleanPath)
	mdParser, renderer := handler.markdownArgs()

	// If file extension was not provided...
	if extension == "" {

		_, dirErr := os.Stat(filepath.Join(handler.dir, cleanPath))
		_, fileErr := os.Stat(filepath.Join(handler.dir, cleanPath+".md"))

		// If not a directory nor an extension-less markdown file, return an HTTP 404.
		if dirErr != nil && fileErr != nil {
			w.WriteHeader(404)
			return
		}

		// Directories take precedence over extension-less markdown files. Check if directory...
		if dirErr == nil {
			handler.handleDirectory(w, r)
			return
		}

		// Reply with HTTP 404 if file extension is required, since the path isn't a directory.
		if handler.requireExt {
			w.WriteHeader(404)
			return
		}

		// otherwise append it so we can properly find the files.
		// WARN: note, this means we will not support files which do not include a file extension.
		cleanPath = cleanPath + ".md"
	}

	fileContent, err := ioutil.ReadFile(filepath.Join(handler.dir, cleanPath))
	if err != nil {
		w.WriteHeader(404)
		return
	}

	var parent Node
	var children []Node

	// If not at root...
	if filepath.Dir(cleanPath) != cleanPath {
		parent, _, err = readNodes(handler.dir, filepath.Join(handler.dir, filepath.Dir(cleanPath)))
		if err != nil {
			w.WriteHeader(500)
			return
		}
	}

	node, children, err := readNodes(handler.dir, filepath.Join(handler.dir, cleanPath))
	if err != nil {
		w.WriteHeader(500)
		return
	}
	renderedHTML := markdown.ToHTML(fileContent, mdParser, renderer)
	data := newTemplateDataBuilder().WithContent(string(renderedHTML)).WithNode(node, parent, children).Build()

	if err := handler.template.Execute(w, data); err != nil {
		log.Println("failed to execute template", err)
		w.WriteHeader(500)
		return
	}
}

func (handler markdownHandler) handleDirectory(w http.ResponseWriter, r *http.Request) {
	cleanPath := filepath.Clean(r.URL.Path)
	mdParser, renderer := handler.markdownArgs()
	dirInfo, _ := os.Stat(filepath.Join(handler.dir, cleanPath)) // error should have been checked by caller.

	// The requested path exists, but it is not a directory. Throw a HTTP 404 for now.
	// TODO: update code to handle name collisions between files and directories.
	if !dirInfo.IsDir(){
		w.WriteHeader(404)
		return
	}

	// If we are hiding files instead of listing them, reply with an HTTP 404.
	if handler.hideListing {
		w.WriteHeader(404)
		return
	}

	// Okay. They requested a directory, it exists, and
	//the server is allowed to list the directories contents.
	// Lets grab the immediate children, generate markdown, and render it...
	dir, err := os.Open(filepath.Join(handler.dir, cleanPath))
	if err != nil {
		// well how did this happen? Log and throw an HTTP 500.
		log.Println("error opening directory:", err)
		w.WriteHeader(500)
		return
	}

	contents, err := dir.Readdir(0)
	if err != nil {
		log.Println("error reading directory contents:", err)
		w.WriteHeader(500)
		return
	}

	buff := new(bytes.Buffer)
	for _, f := range contents {
		// Only include directories, or files with markdown extension.
		// TODO: what about mardkwon files without a file extension?
		if f.IsDir() || filepath.Ext(f.Name()) == ".md" {
			buff.WriteString(fmt.Sprintf("* %s\n", f.Name()))
		}
	}

	renderedHTML := markdown.ToHTML(buff.Bytes(), mdParser, renderer)
	if cleanPath == "/" {
		cleanPath = ""
	}

	node, children, err := readNodes(handler.dir, filepath.Join(handler.dir, cleanPath))
	if err != nil {
		w.WriteHeader(500)
		return
	}

	var parent Node

	// If not at root...
	if filepath.Dir(cleanPath) != cleanPath {
		parent, _, err = readNodes(handler.dir, filepath.Join(handler.dir, filepath.Dir(cleanPath)))
		if err != nil {
			w.WriteHeader(500)
			return
		}
	}

	data := newTemplateDataBuilder().WithContent(string(renderedHTML)).WithNode(node, parent, children).Build()

	if err := handler.template.Execute(w, data); err != nil {
		log.Println("failed to execute template", err)
		w.WriteHeader(500)
		return
	}
}

func (handler markdownHandler) markdownArgs() (*parser.Parser, *html.Renderer) {
	extensions := parser.CommonExtensions | parser.AutoHeadingIDs
	htmlFlags := html.CommonFlags | html.HrefTargetBlank
	opts := html.RendererOptions{Flags: htmlFlags}
	mdParser := parser.NewWithExtensions(extensions)
	renderer := html.NewRenderer(opts)
	return mdParser, renderer
}

func (handler markdownHandler) handleMedia(w http.ResponseWriter, r *http.Request) {
	cleanPath := filepath.Clean(r.URL.Path)

	// if we have a media file but are not set to serve media, return HTTP 404.
	if handler.media == "" || handler.mediaPrefix == "" {
		w.WriteHeader(404)
		return
	}

	// if media is allowed, but doesn't start with the prefix, return HTTP 404.
	if !strings.HasPrefix(cleanPath, handler.mediaPrefix) {
		w.WriteHeader(404)
		return
	}

	// Strip media prefix (since it may not match the media dir)
	cleanPath = cleanPath[len(handler.mediaPrefix):]

	filePath := filepath.Join(handler.media, cleanPath)
	http.ServeFile(w, r, filePath)
}

func main() {
	args := os.Args[1:]

	progArgs, err := parseProgramArguments(args)
	if err != nil {
		os.Exit(1)
	}

	if progArgs.autocert != "" && progArgs.port != 443 {
		fmt.Println("port must be 443 when using an autogenerated cert")
		fmt.Println("Use -p 443 to set the right port.")
		os.Exit(1)
	}

	templateContent := defaultTemplateContent

	if progArgs.templatePath != "" {
		byteContents, err := ioutil.ReadFile(progArgs.templatePath)
		if err != nil {
			fmt.Println("failed to read template file", progArgs.templatePath)
			fmt.Println("error:", err)
			os.Exit(1)
		}
		templateContent = string(byteContents)
	}

	parse, err := template.New("page").Funcs(templateFunctions).Parse(templateContent)
	if err != nil {
		log.Println("failed to parse default template", err)
		os.Exit(-1)
	}

	handler := markdownHandler{
		requireExt:  progArgs.requireExt,
		dir:         filepath.Clean(progArgs.dir),
		media:       filepath.Clean(progArgs.media),
		mediaPrefix: progArgs.mediaPrefix,
		hideListing: progArgs.hideListing,
		template:    parse,
	}

	// Server startup logs:
	reqExt := "yes"
	if !progArgs.requireExt {
		reqExt = "no"
	}

	isServingMedia := "yes"
	if len(progArgs.media) == 0 || len(progArgs.mediaPrefix) == 0 {
		isServingMedia = "no"
	}

	hideFileListing := "no"
	if progArgs.hideListing {
		hideFileListing = "yes"
	}

	isUsingSSLCert := "no"
	if progArgs.autocert != "" {
		isUsingSSLCert = "yes"
	}

	log.Println("startup information:")
	log.Println("\tport:", progArgs.port)
	log.Println("\tis using auto SSL cert:", isUsingSSLCert)
	log.Println("\tcert domain:", progArgs.autocert)
	log.Println("\tis hiding file listing:", hideFileListing)
	log.Println("\thideListing:", progArgs.hideListing)
	log.Println("\ttemplate:", progArgs.templatePath)
	log.Println("")
	log.Println("\trequire markdown extension:", reqExt)
	log.Println("\tdir:", progArgs.dir)
	log.Println("\tserving media files:", isServingMedia)
	log.Println("\tmedia:", progArgs.media)
	log.Println("\tmediaPrefix:", progArgs.mediaPrefix)

	mux := http.NewServeMux()
	mux.HandleFunc("/", handler.handle)

	var tlsConfig *tls.Config

	if progArgs.autocert != "" {
		certManager := autocert.Manager{
			Prompt:     autocert.AcceptTOS,
			HostPolicy: autocert.HostWhitelist(progArgs.autocert),
			Cache:      autocert.DirCache("certs"),
		}

		tlsConfig = certManager.TLSConfig()
	}

	s := &http.Server{
		Addr:           fmt.Sprintf(":%d", progArgs.port),
		Handler:        mux,
		ReadTimeout:    5 * time.Second,
		WriteTimeout:   5 * time.Second,
		MaxHeaderBytes: 1 << 20,
		TLSConfig:      tlsConfig,
	}

	log.Printf("Starting server (:%d)...\n", progArgs.port)
	if progArgs.autocert != "" {
		log.Fatal(s.ListenAndServeTLS("", ""))
	} else {
		log.Fatal(s.ListenAndServe())
	}
}
